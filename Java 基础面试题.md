### Java 基础

- [Java 基础](#toc_0)
- [初级题](#toc_1)
- - [Set、List、Map的区别和联系](#toc_2)
  - [volatie和synchronied的区别](#toc_3)
  - [接口和抽象类的区别，什么时候使用](#toc_4)
  - [类加载机制的步骤，每一步做了什么，static和final修改的成员变量的加载时机](#toc_5)
  - [内部类：静态内部类和匿名内部类的使用和区别](#toc_6)
  - [字符串不变性](#toc_7)
  - [equals()方法、hashCode()方法的区别](#toc_8)
  - [map怎么实现hashcode和equals,为什么重写equals必须重写hashcode](#toc_9)
  - [java中==和equals和hashCode的区别](#toc_10)
  - [Java异常类的层次结构](#toc_11)
  - [String、StringBuffer、StringBuilder有什么区别？](#toc_12)
  - [String可以被子类继承吗？](#toc_13)
  - [HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？](#toc_14)
  - [HashMap的链表结构设计是用来解决什么问题的？](#toc_15)
  - [说说反射机制的作用。反射机制会不会有性能问题？](#toc_16)
  - [正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？](#toc_17)
  - [try、catch、finally语句块的执行顺序。](#toc_18)
- [中级题](#toc_19)
- - [哪些集合类是线程安全的](#toc_20)
  - [Arrays.sort的实现](#toc_21)
  - [什么时候使用CopyOnArrayList](#toc_22)
  - [CAS和AQS的实现原理](#toc_23)
  - [reentrantlock的实现和Synchronied的区别](#toc_24)
  - [双亲委派模型](#toc_25)
  - [反射机制：反射动态擦除泛型、反射动态调用方法等](#toc_26)
  - [动态绑定：父类引用指向子类对象](#toc_27)
  - [JVM内存管理机制：有哪些区域，每个区域做了什么](#toc_28)
  - [JVM垃圾回收机制：垃圾回收算法 垃圾回收器 垃圾回收策略](#toc_29)
  - [jvm参数的设置和jvm调优](#toc_30)
  - [什么情况产生年轻代内存溢出、什么情况产生年老代内存溢出](#toc_31)
  - [Redis和memcached](#toc_32)
  - [java中bio nio aio的区别和联系](#toc_33)
  - [为什么bio是阻塞的 nio是非阻塞的 nio是模型是什么样的](#toc_34)
  - [ClassNotFoundException , NoClassDefFoundError , ClassCastException](#toc_35)
  - [Java io的整体架构和使用的设计模式](#toc_36)
  - [泛型与类型擦除](#toc_37)
  - [rpc相关：如何设计一个rpc框架，从io模型 传输协议 序列化方式综合考虑](#toc_38)
  - [Linux命令 统计，排序，前几问题等](#toc_39)
  - [StringBuff 和StringBuilder的实现，底层实现是通过byte数据，外加数组的拷贝来实现的](#toc_40)
  - [内存缓存和数据库的一致性同步实现](#toc_41)
  - [微服务的优缺点](#toc_42)
  - [线程池的参数问题](#toc_43)
  - [ip问题 如何判断ip是否在多个ip段中](#toc_44)
  - [判断数组两个中任意两个数之和是否为给定的值](#toc_45)
  - [synchronized实现原理](#toc_46)
  - [消息队列广播模式和发布/订阅模式的区别](#toc_47)
  - [生产者消费者代码实现](#toc_48)
  - [死锁代码实现](#toc_49)
  - [线程池：参数，每个参数的作用，几种不同线程池的比较，阻塞队列的使用，拒绝策略](#toc_50)
  - [Future和ListenableFuture 异步回调相关](#toc_51)
  - [在Java中wait和seelp方法的不同](#toc_52)
  - [什么时候需要加volatile关键字？它能保证线程安全吗？](#toc_53)
  - [concurrentHashMap怎么实现？concurrenthashmap在1.8和1.7里面有什么区别](#toc_54)
  - [CountDownLatch、LinkedHashMap、AQS实现原理](#toc_55)
  - [OOM说一下？怎么排查？哪些会导致OOM?](#toc_56)
  - [说说一致性 Hash 原理](#toc_57)
  - [分布式一致性协议，二段、三段、TCC，优缺点](#toc_58)
  - [Java的内存模型，Java8做了什么修改](#toc_59)
  - [如何进行JVM调优？有哪些方法？](#toc_60)
  - [怎么理解强一致性、单调一致性和最终一致性？](#toc_61)
  - [谈一谈一致性哈希算法。](#toc_62)
  - [序列化方案都有哪些，说说它们的优缺点？](#toc_63)
  - [Java对象引用四个级别（强、软、弱、虚）](#toc_64)
  - [解析XML的几种方式的原理与特点：DOM、SAX](#toc_65)

---

#### 初级题

##### Set、List、Map的区别和联系

1. 什么时候使用Hashmap
2. 什么时候使用Linkedhashmap、Concurrenthashmap、Weakhashmap
3. 为什么Set、List、Map不实现Cloneable和Serializable接口

##### volatie和synchronied的区别

##### 接口和抽象类的区别，什么时候使用

1. java8里面接口的默认实现
2. 2个接口有同样默认实现该怎么处理

##### 类加载机制的步骤，每一步做了什么，static和final修改的成员变量的加载时机

##### 内部类：静态内部类和匿名内部类的使用和区别

##### 字符串不变性

![img](https://cdn.nlark.com/yuque/0/2019/png/406432/1565342397037-77d74d8b-5dc0-422e-8ee4-a508ee9fada8.png)

##### equals()方法、hashCode()方法的区别

HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于：

- 如果两个对象相等(equal)，那么他们一定有相同的哈希值。
- 如果两个对象的哈希值相同，但他们未必相等(equal)。

##### map怎么实现hashcode和equals,为什么重写equals必须重写hashcode

##### java中==和equals和hashCode的区别

##### Java异常类的层次结构

![img](https://cdn.nlark.com/yuque/0/2019/png/406432/1565342412803-774a62d3-e6c1-488a-be94-dd0b949492c3.png)

##### String、StringBuffer、StringBuilder有什么区别？

##### String可以被子类继承吗？

##### HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？

##### HashMap的链表结构设计是用来解决什么问题的？

##### 说说反射机制的作用。反射机制会不会有性能问题？

##### 正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？

##### try、catch、finally语句块的执行顺序。

#### Java语言

##### 数组和链表的区别

数组和链表的区别主要表现在以下几个方面：
逻辑结构

（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素

（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素 (3)需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存
内存结构	数组从栈上分配内存，使用方便，但是自由度小	链表从堆上分配内存，自由度大，但是要注意内存泄漏
访问效率	数组在内存中顺序存储，可通过下标访问，访问效率高	链表访问效率低，如果想要访问某个元素，需要从头遍历
越界问题	数组的大小是固定的， [组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。

ArrayList 继承了 AbstractList ，并实现了 List 接口。

int数组转List`<Integer>`集合 以及 List`<Integer>`集合转int数组

```java
int[] intArr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };

// int[] -> List<Integer>
List<Integer> integerList = Arrays.stream(intArr).boxed().collect(Collectors.toList());
// List<Integer> -> int[]
intArr = integerList.stream().mapToInt(Integer::intValue).toArray();
```

int数组转Integer[] 数组 以及 Integer[] 转int 数组

```java
// int[] -> Integer[]
Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
// Integer[] -> int[]
intArr  = Arrays.stream(integerArr).mapToInt(Integer::valueOf).toArray();
```

Integer数组转List`<Integer>`集合 以及 List`<Integer>` 集合转Integer数组

```java
// Integer[] -> List<Integer>
integerList = Arrays.asList(integerArr);
// List<Integer> -> Integer[]
integerArr = integerList.toArray(new Integer[integerList.size()]);
```

##### BeanFactory和FactoryBean区别

**BeanFactory:**所有Spring Bean的容器根接口，给Spring 的容器定义一套规范，给IOC容器提供了一套完整的规范，比如我们常用到的getBean方法等

**FactoryBean:**SpringIOC容器是创建Bean的一种形式，这种方式创建Bean会有加成方式，融合了简单的工厂设计模式于装饰器模式

区别

1. BeanFactory:负责生产和管理Bean的一个工厂接口，提供一个Spring Ioc容器规范,
2. FactoryBean: 一种Bean创建的一种方式，对Bean的一种扩展。对于复杂的Bean对象初始化创建使用其可封装对象的创建细节。

##### extends与implements的不同

1、在类的声明中，通过关键字extends来创建一个类的子类。

一个类通过关键字implements声明自己使用一个或者多个接口。

extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法;

implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用

2、extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承

JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，

但implements可以实现多个接口，用逗号分开就行了 比如 ：

class A extends B implements C,D,E

接口实现的注意点：

a.实现一个接口就是要实现该接口的所有的方法(抽象类除外)。

b.接口中的方法都是抽象的。

c.多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。

##### 原型模式和单例模式的区别

1.1. 原型模式

用**原型模式**是在已指定对象的基础上，然后通过拷贝这些**原型**对象创建新的对象。

当要实例化的类是在运行时刻指定或者为了避免创建一个与产品类层次平行的工厂类层次时或者当一个类的实例只能有几个不同状态组合中的一种时 —— 建立相应数目的**原型**并**克隆**它们可能比每次用合适的状态手工实例化该类更方便一些。

1.2. 单例模式

单态**设计模式**的核心就是：将类的构造方法私有化，之后在类的内部产生实例化对象，并通过静态方法返回实例化对象的应用。

如果不希望一个类产生更多对象的情况下，必须使用**单态模式**，所谓单态就是在对象的入口处（构造方法）限制了对象的实例化操作。

##### hashCode与equals的区别与联系

1、equals方法用于比较对象的内容是否相等（覆盖以后）

2、hashcode方法只有在集合中用到

3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。

4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。

##### 进程和线程的区别与联系

【区别】：

调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；

并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；

拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；

系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。

【联系】：

+ 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
+ 资源分配给进程，同一进程的所有线程共享该进程的所有资源；
+ 处理机分给线程，即真正在处理机上运行的是线程；
+ 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

  协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。

  协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；

不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

##### 线程的 run() 和 start() 有什么区别？

调用 start() 方法是用来启动线程的，轮到该线程执行时，会自动调用 run()；直接调用 run() 方法，无法达到启动多线程的目的，相当于主线程线性执行 Thread 对象的 run() 方法。
一个线程对线的 start() 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常；run() 方法没有限制。

##### 线程的5种状态

1. **新建(NEW)**：新创建了一个线程对象。
2. **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行[线程池](https://so.csdn.net/so/search?q=线程池&spm=1001.2101.3001.7020)中，等待被线程调度选中，获取cpu 的使用权 。
3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
4. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

##### 线程池的五种状态

线程池一共有五种状态, 分别是：

1. RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务。
2. SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。
3. STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。
4. TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
5. TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。进入TERMINATED的条件如下：
   - 线程池不是RUNNING状态；
   - 线程池状态不是TIDYING状态或TERMINATED状态；
   - 如果线程池状态是SHUTDOWN并且workerQueue为空；
   - workerCount为0；
   - 设置TIDYING状态成功。

##### 线程池中的几种重要的参数及流程

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

`corePoolSize`：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中

`maximumPoolSize`：线程池最大线程数最大线程数

`keepAliveTime`：表示线程没有任务执行时最多保持多久时间会终止

`unit`：参数keepAliveTime的时间单位TimeUtil类的枚举类（DAYS、HOURS、MINUTES、SECONDS 等）

`workQueue`：阻塞队列，用来存储等待执行的任务

`threadFactory`：线程工厂，主要用来创建线程

`handler`：拒绝处理任务的策略

- `AbortPolicy`：丢弃任务并抛出 RejectedExecutionException 异常。（默认这种）
- `DiscardPolicy`：也是丢弃任务，但是不抛出异常
- `DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
- `CallerRunsPolicy`：由调用线程处理该任务

**执行流程**

1. 当有任务进入时，线程池创建线程去执行任务，直到核心线程数满为止
2. 核心线程数量满了之后，任务就会进入一个缓冲的任务队列中
   1. 当任务队列为无界队列时，任务就会一直放入缓冲的任务队列中，不会和最大线程数量进行比较
   2. 当任务队列为有界队列时，任务先放入缓冲的任务队列中，当任务队列满了之后，才会将任务放入线程池，此时会拿当前线程数与线程池允许的最大线程数进行比较，如果超出了，则默认会抛出异常。如果没超出，然后线程池才会创建线程并执行任务，当任务执行完，又会将缓冲队列中的任务放入线程池中，然后重复此操作。

##### CAS原理

**什么是CAS？**

CAS：Compare and Swap，即比较再交换。

jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。

**2、CAS算法理解**

对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

##### Java 实现线程安全的方式

（1）同步方法：即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

（2）同步代码块：即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

（3）使用特殊域变量(volatile)实现线程同步

  a.volatile关键字为域变量的访问提供了一种免锁机制
  b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新
  c.因此每次使用该域就要重新计算，而不是使用寄存器中的值
  d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

（4）使用重入锁实现线程同步

  在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。
   ReenreantLock类的常用方法有：
     ReentrantLock() : 创建一个ReentrantLock实例
     lock() : 获得锁
     unlock() : 释放锁
  注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用

如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 。如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁

（5）使用局部变量实现线程同步

如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

（7）使用阻塞队列实现线程同步

（8）使用原子变量实现线程同步

##### java中的final关键字的作用：

1、用来修饰一个引用；2、用来修饰一个方法；3、用来修饰类。当final修饰方法时，这个方法会成为最终方法，无法被子类重写。

1、用来修饰一个引用

如果引用为基本数据类型，则该引用为常量，该值无法修改； 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

2、用来修饰一个方法

当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

3、用来修饰类

当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。

**JDK 和 CGLib动态代理区别**

**1、JDK动态代理具体实现原理：**

- 通过实现InvocationHandler接口创建自己的调用处理器；
- 通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；
- 通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；
- 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；

JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

**2、CGLib动态代理：**

CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。

**3、****两者对比：**

- JDK动态代理是面向接口的。
- CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。

##### 接口与抽象类的区别与联系

- 接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。
- 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。
- 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
- 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。

接口和抽象类很像，它们都具有如下共同的特征：

- 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

##### 描述一下Map put的过程

1. 首次扩容：

   先判断数组是否为空，若数组为空则进行第一次扩容（resize）；
2. 计算索引：

   通过hash算法，计算键值对在数组中的索引；
3. 插入数据：

   - 如果当前位置元素为空，则直接插入数据；
   - 如果当前位置元素非空，且key已存在，则直接覆盖其value；
   - 如果当前位置元素非空，且key不存在，则将数据链到链表末端；
   - 若链表长度达到8，则将链表转换成红黑树，并将数据插入树中；
4. 再次扩容

   如果数组中元素个数（size）超过threshold，则再次进行扩容操作。

##### synchronized与Lock的区别

**参考答案**

1. synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。
2. synchronized可以用在代码块上、方法上；Lock只能写在代码里。
3. synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。
4. synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。
5. synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。
6. synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率。

##### 偏向锁/轻量级锁/重量级锁

**这三种锁是指锁的状态**，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。**这三种锁的状态是通过对象监视器在对象头中的字段来表明的**。

**偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价**。

**轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁**，不会阻塞，提高性能。

**重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数(默认10次)的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。**重量级锁会让其他申请的线程进入阻塞，性能降低。

##### 什么是字节码?采用字节码的好处是什么?

字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。

采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

##### **varchar和char 的区别：**

区别一，定长和变长

char 表示定长，长度固定，varchar表示变长，即长度可变。当所插入的字符串超出它们的长度时，视情况来处理，如果是严格模式，则会拒绝插入并提示错误信息，如果是宽松模式，则会截取然后插入。如果插入的字符串长度小于定义长度时，则会以不同的方式来处理，如char（10），表示存储的是10个字符，无论你插入的是多少，都是10个，如果少于10个，则用空格填满。而varchar（10），小于10个的话，则插入多少个字符就存多少个。
varchar怎么知道所存储字符串的长度呢？实际上，对于varchar字段来说，需要使用一个（如果字符串长度小于255）或两个字节（长度大于255）来存储字符串的长度。但是因为他需要有一个prefix来表示他具体bytes数是多少（因为varchar是变长的，没有这个长度值他不知道如何读取数据）。

区别之二，存储的容量不同

对 char 来说，最多能存放的字符个数 255，和编码无关。
而 varchar 呢，最多能存放 65532 个字符。VARCHAR 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节

##### 为什么说 Java 语言“编译与解释并存”？

一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。
二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)上的，所以它是解释运行的，那也就算是解释的了。
三、但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)代码编译为本地的代码直接运行，所以，又是编译的。

##### 一个类的构造方法的作用是什么，若一个类没有声明构造方法，该程序能正确执行吗？为什么？

构造方法主要作用是完成对类对象的初始化工作。

如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。

##### 字符型常量和字符串常量的区别?

1.从形式上

> [字符常量](https://so.csdn.net/so/search?q=字符常量&spm=1001.2101.3001.7020)是单引号引起来的一个字符，而字符串常量是双引号引起来的若干字符。

2.从含义上

> 字符常量相当于一个整数型（ASCII值），可以参加[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)运算；字符串常量代表一个地址值（该字符串在内存中存放的地址）。

3.从占[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)大小

> 字符常量只占两个字节，字符串常量占若干字节。（在Java中char占两个字节）

##### 静态方法为什么不能调用非静态成员?

静态成员在类的初始化的时候就已经加载到了内存，可以通过类名.访问，而非静态成员是在类实例化后出现的。所以在非静态成员不存在的时候，静态方法就已经存在了，此时调用非静态成员是非法操作。

##### Java8有哪些新特性

(1)Lambda 表达式 (2) 方法引用通过方法的名字来指向一个方法 (3) 函数式接口(FunctionalInterface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口 (4) Java 8 新增了接口的默认方法 (5) Java 8 API添加了一个新的抽象称为流Stream (6) Optional 类是一个可以为null的容器对象

##### 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是ArrayList？

Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。

#### JVM

##### jvm内存结构

- 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。

堆的作用是存放对象实例和数组。从结构上来分，可以分为新生代和老年代。垃圾回收机制有三种，minor gc，major gc 和full gc。针对于堆的就是前两种。年轻代的叫 minor gc，老年代的叫major gc。而新生代又可以分为Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。 所有新生成的对象首先都是放在新生代的。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年代的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。

- 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。

永久代是hotspot虚拟机，也就是我们使用的java虚拟机的特有的概念，他不属于堆内存，是方法区的一种实现，各大厂商对方法区有各自的实现。永久代存放jvm运行时，需要的类，包含java库的类和方法，在触发full gc的情况下，永久代也会被进行垃圾回收。永久代的内存溢出也就是 pergen space。

- 方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。
- 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
- 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。

##### 如何设置JVM内存大小：

具体来讲：

Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍

永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。

年轻代Xmn的设置为老年代存活对象的1-1.5倍。

老年代的内存大小设置为老年代存活对象的2-3倍。

##### JVM的符号引用和直接引用

1.符号引用（Symbolic References）：

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。

符号引用与[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。

2.直接引用：
直接引用可以是
（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
（3）一个能间接定位到目标的句柄
直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

##### JVM的类加载机制

 全盘负责：当一个类加载器加载某个Class时，该Class所依赖和引用的其它Class也将由该类加载器负责载入，除非显式的使用另外一个类加载器来载入。

双亲委派：当一个类加载器收到了类加载请求，它会把这个请求委派给父（parent）类加载器去完成，依次递归，因此所有的加载请求最终都被传送到顶层的启动类加载器中。只有在父类加载器无法加载该类时子类才尝试从自己类的路径中加载该类。（注意：类加载器中的父子关系并不是类继承上的父子关系，而是类加载器实例之间的关系。）

缓存机制：缓存机制会保证所有加载过的Class都会被缓存，当程序中需要使用某个类时，类加载器先从缓冲区中搜寻该类，若搜寻不到将读取该类的二进制数据，并转换成Class对象存入缓冲区中。这就是为什么修改了Class后需重启JVM才能生效的原因。
JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：

1）**Bootstrap ClassLoader** 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。

2）**Extension ClassLoader** 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。

3）**App ClassLoader** 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。

4）**Custom ClassLoader** 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

##### G1垃圾回收器

G1垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器。G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。G1回收器和CMS比起来，有以下不同：

1. G1垃圾回收器是compacting的，因此其回收得到的空间是连续的。这避免了CMS回收器因为不连续空间所造成的问题。如需要更大的堆空间，更多的floating garbage。连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式；
2. G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；

G1还有一个及其重要的特性：软实时（soft real-time）。所谓的实时垃圾回收，是指在要求的时间内完成垃圾回收。“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。

##### JVM性能调优实战——UseParallelGC

jdk1.8默认使用ParallelGC。新生代采用的是Parallel Scavenge，Parallel Scavenge是Java1.8默认的收集器，特点是并行的多线程回收，以吞吐量优先。老年代Parallel Old。Parallel Old:是Parallel Scavenge收集器的老年代版本，用于老年代的垃圾回收，但与Parallel Scavenge不同的是，它使用的是“标记-整理算法”。适用于注重于吞吐量及CPU资源敏感的场合。并发垃圾收集器调优的内容一般为：
1）关闭jvm自动分配策略。
2）survivior空间调优。
通过这两点调整，使创建的对象按照设定的阈值执行。

1. G1在jdk6的时候是已经出现了，JDK 7 u9 或更高版本可以使用，在jdk9的时候成为默认的垃圾回收器。因为我们是jdk8所以是需要设置参数指定的。

```text
-Xms24g -Xmx24g -XX:+UseG1GC -XX:MaxGCPauseMillis=95
//最大堆内存24G 使用G1GC，设置预期停顿时间是95ms
```

1. 使用G1的主要原因是：G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。
   目标很明确，可控的GC时间。
2. 升级启用了G1后解惑不尽人意，甚至比CMS的结果还差，我们来看下G1，几个优于CMS的几个特点，以及实现。

##### volatile关键字有什么用？

**参考答案**

当一个变量被定义成volatile之后，它将具备两项特性：

1. 保证可见性

   当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的volatile变量缓存无效。
2. 禁止指令重排

   使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：

   - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；
   - 在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

   即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。

注意，虽然volatile能够保证可见性，但它不能保证原子性。volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。

##### volatile的实现原理

volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

##### volatile和synchronized的区别

1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

##### PECS原则：Producer Extends Consumer Super

`<? extends T>`和 `<? super T>`是Java泛型中的**“通配符（Wildcards）”**和**“边界（Bounds）”**的概念。

- <? extends T>：是指 **“上界通配符（Upper Bounds Wildcards）”**

上界<? extends T>不能往里存，只能往外取

- <? super T>：是指 **“下界通配符（Lower Bounds Wildcards）”**

下界<? super T>不影响往里存，但往外取只能放在Object对象里

**如果参数化类型表示一个生产者，就使用<? extends T>；如果它表示一个消费者，就使用<? super T>**

最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：

- **频繁往外读取内容的，适合用上界Extends。**
- **经常往里插入的，适合用下界Super。**

在 `List<? extends Fruit>`的泛型集合中,对于元素的类型,编译器只能知道元素是继承自Fruit,具体是Fruit的哪个子类,这是无法知道的,所以向一个无法知道具体类型的泛型集合中插入元素是不能通过编译的.但是,由于知道元素是继承自Fruit,所以从这个泛型集合中取Fruit类型的元素是可以的.

在 `List<? super Apple>`的泛型集合中,元素的类型是Apple的父类,但无法知道是哪个具体的父类,因此读取元素时无法确定以哪个父类进行读取.插入元素时,可以插入Apple与Apple的父类,因为这个集合中的元素都是Apple的父类.

**总结**

只读不可写时,使用 `List<? extends Fruit>`:Producer
只写不可读时,使用 `List<? super Apple>`:Consumer

##### NIO/BIO

三种IO模型即为BIO【同步阻塞IO】：在BIO模式下，数据的写入和读取都必须阻塞在一个线程中执行，在写入完成或读取完成前，线程阻塞。

NIO【同步非阻塞IO】：NIO相对于BIO来说出现了几个核心的组件，分别是 Selector（选择器） 、 Channle（通道） 和 Buffer（缓冲区） 。NIO出现于JDK 1.4之后。

缓冲区([Buffer](https://so.csdn.net/so/search?q=Buffer&spm=1001.2101.3001.7020))就是在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储，这部分预留的内存空间就叫做缓冲区：

使用缓冲区有这么两个好处：

1、减少实际的物理读写次数

2、缓冲区在创建时就被分配[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)，这块内存区域一直被重用，可以减少动态分配和回收内存的次数

AIO【异步非阻塞IO】

##### 两种 NIO 实现：[Selector](https://so.csdn.net/so/search?q=Selector&spm=1001.2101.3001.7020) 与 Epoll

Selector 管理被注册的通道的集合的信息和其就绪状态，同时也更新通道的就绪状态。并且一个通道可以被注册到多个选择器上，而对于同一个选择器则只能被注册一次。**Selector** 一般称 为**选择器** ，当然你也可以翻译为 **多路复用器** 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。

[Epoll](https://so.csdn.net/so/search?q=Epoll&spm=1001.2101.3001.7020)是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
